import ServerCookies from 'cookies';
import ClientCookies from 'cookies-js';
import withRedux from 'next-redux-wrapper';
import { Component, createElement } from 'react';
import { createStore } from 'redux';
import { createPersistoid, getStoredState, persistReducer, persistStore } from 'redux-persist';
import { CookieStorage, NodeCookiesWrapper } from 'redux-persist-cookie-storage';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const defaultPersistConfig = {
    key: "root",
    blacklist: [],
};
const defaultConfig = {
    persistConfig: defaultPersistConfig,
    cookieConfig: {},
};
const withReduxCookiePersist = (makeStore, config) => {
    config = Object.assign(Object.assign({}, defaultConfig), config);
    const { persistConfig, cookieConfig } = config, reduxWrapperConfig = __rest(config, ["persistConfig", "cookieConfig"]);
    const sharedPersistConfig = Object.assign(Object.assign({}, defaultPersistConfig), persistConfig);
    const sharedCookieConfig = Object.assign({ setCookieOptions: {} }, cookieConfig);
    const debug = reduxWrapperConfig.debug || false;
    const extractStateFromCookies = (req, res) => __awaiter(void 0, void 0, void 0, function* () {
        // @ts-ignore https://github.com/ScottHamper/Cookies/pull/83
        const cookies = new NodeCookiesWrapper(new ServerCookies(req, res));
        const persistConfig = Object.assign(Object.assign({}, sharedPersistConfig), { storage: new CookieStorage(cookies) });
        let state;
        try {
            state = yield getStoredState(persistConfig);
        }
        catch (error) {
            /* istanbul ignore if */
            if (debug) {
                console.log("getStoredState() failed (this happens when the index storage item is not set):\n", error);
            }
        }
        // Removing the state's _persist key for the server-side (non-persisted) redux store
        if (state && typeof state._persist !== "undefined") {
            const cleanedState = __rest(state, ["_persist"]);
            state = cleanedState;
        }
        return state;
    });
    // Used internally by flushReduxStateToCookies()
    const createPersistor = (store) => new Promise((resolve) => {
        const persistor = persistStore(store, {}, () => {
            resolve(persistor);
        });
    });
    function flushReduxStateToCookies() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!(this.req && this.res)) {
                if (debug) {
                    console.log("flushReduxStateToCookies only works on the server " +
                        "in your app's getInitialProps() method. Ignoring the call.");
                }
                return;
            }
            /* istanbul ignore if */
            if (debug) {
                console.log("Flushing the store's current state to cookies via flushReduxStateToCookies...");
            }
            // @ts-ignore https://github.com/ScottHamper/Cookies/pull/83
            const cookies = new NodeCookiesWrapper(new ServerCookies(this.req, this.res));
            const persistConfig = Object.assign(Object.assign({}, sharedPersistConfig), { blacklist: sharedPersistConfig.blacklist.concat(["_persist"]), storage: new CookieStorage(cookies, Object.assign(Object.assign({}, sharedCookieConfig), { setCookieOptions: Object.assign(Object.assign({}, sharedCookieConfig.setCookieOptions), { httpOnly: false }) })), stateReconciler(inboundState, originalState) {
                    // Ignore state from cookies, only use the store's current state
                    return originalState;
                } });
            // Using a dummy reducer here as we do not dispatch actions to this store
            const reducer = persistReducer(persistConfig, (state, action) => state);
            const store = createStore(reducer, this.store.getState());
            const persistor = yield createPersistor(store);
            // Set cookies
            yield persistor.flush();
            /* istanbul ignore if */
            if (debug) {
                console.log("State flushed to cookies: ", store.getState());
            }
        });
    }
    const wrappedMakeStore = (initialState, options) => {
        if (options.req && options.res) {
            initialState = options.req.__initialReduxCookieState;
        }
        const store = makeStore(initialState, options);
        if (!options.isServer) {
            // Let's persist the store!
            const persistConfig = Object.assign(Object.assign({}, sharedPersistConfig), { storage: new CookieStorage(ClientCookies) });
            // Note: We do not create a persistor here because we need no rehydration.
            // See https://github.com/rt2zz/redux-persist/issues/457#issuecomment-362490893 for the idea
            const persistoid = createPersistoid(persistConfig);
            store.subscribe(() => persistoid.update(store.getState()));
        }
        return store;
    };
    return (App) => {
        var _a;
        // Wrap the provided App with next-redux-wrapper
        const WrappedApp = withRedux(wrappedMakeStore, reduxWrapperConfig)(App);
        return _a = class CookiePersistedWrappedApp extends Component {
                render() {
                    return createElement(WrappedApp, Object.assign({}, this.props));
                }
            },
            _a.displayName = `withReduxCookiePersist(${WrappedApp.displayName})`,
            _a.getInitialProps = (appCtx) => __awaiter(void 0, void 0, void 0, function* () {
                if (appCtx.ctx.req && appCtx.ctx.res) {
                    /* istanbul ignore if */
                    if (debug) {
                        console.log("0. Extracting state from cookies (if any)");
                    }
                    const state = yield extractStateFromCookies(appCtx.ctx.req, appCtx.ctx.res);
                    /* istanbul ignore if */
                    if (debug) {
                        console.log("0. Got state", state);
                    }
                    // Illegally attaching the extracted state to the request object so we can access it later
                    // on in our makeStore wrapper
                    appCtx.ctx.req.__initialReduxCookieState = state;
                }
                appCtx.ctx.flushReduxStateToCookies = flushReduxStateToCookies;
                return yield WrappedApp.getInitialProps(appCtx);
            }),
            _a;
    };
};

export { withReduxCookiePersist };
